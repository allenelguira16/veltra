{"version":3,"file":"index.js","sources":["../../src/plugins/log-jsx-plugin.ts","../../src/plugins/loop-auto-wrap-plugin.ts","../../src/plugins/wrap-jsx-children-plugin.ts","../../src/plugins/wrap-jsx-expression-plugin.ts","../../src/plugins/wrap-jsx-variables.ts","../../src/plugins/wrap-pure-jsx.ts","../../src/index.ts"],"sourcesContent":["import path from \"node:path\";\nimport { fileURLToPath } from \"node:url\";\n\nimport { NodePath } from \"@babel/core\";\nimport { declare } from \"@babel/helper-plugin-utils\";\nimport * as t from \"@babel/types\";\n\nconst __dirname = path.dirname(fileURLToPath(import.meta.url));\n\n/**\n * Babel plugin to cleanly log <jsx>\n *\n * @param api - The babel api.\n * @returns The babel options.\n */\nexport const logJsxPlugin = declare((api) => {\n  api.assertVersion(7);\n\n  return {\n    name: \"log-jsx-plugin\",\n    visitor: {\n      Program(babelPath, state) {\n        // Skip vynn/core internal\n        if (state.filename?.includes(path.resolve(__dirname, \"../../../vynn\"))) {\n          return;\n        }\n\n        let hasLogJsx = false;\n\n        // Check existing imports\n        babelPath.get(\"body\").forEach((child) => {\n          if (child.isImportDeclaration() && child.node.source.value === \"vynn/jsx-runtime\") {\n            child.node.specifiers.forEach((spec) => {\n              if (t.isImportSpecifier(spec)) {\n                const imported = spec.imported;\n                if (t.isIdentifier(imported) && imported.name === \"logJsx\") {\n                  hasLogJsx = true;\n                }\n              }\n            });\n          }\n        });\n\n        // Insert import if missing\n        if (!hasLogJsx) {\n          const importDecl = t.importDeclaration(\n            [t.importSpecifier(t.identifier(\"logJsx\"), t.identifier(\"logJsx\"))],\n            t.stringLiteral(\"vynn/jsx-runtime\"),\n          );\n          babelPath.unshiftContainer(\"body\", importDecl);\n        }\n      },\n\n      CallExpression(babelPath: NodePath<t.CallExpression>) {\n        const callee = babelPath.get(\"callee\");\n\n        // Detect console.* calls\n        if (\n          t.isMemberExpression(callee.node) &&\n          t.isIdentifier(callee.node.object, { name: \"console\" }) &&\n          t.isIdentifier(callee.node.property)\n        ) {\n          // For each argument, check if JSX\n          const newArgs = babelPath.node.arguments.map((arg) => {\n            if (t.isJSXElement(arg) || t.isJSXFragment(arg)) {\n              return t.callExpression(t.identifier(\"logJsx\"), [arg]);\n            }\n            return arg;\n          });\n\n          // Replace arguments if any JSX was wrapped\n          if (newArgs.some((arg, i) => arg !== babelPath.node.arguments[i])) {\n            babelPath.node.arguments = newArgs;\n          }\n        }\n      },\n    },\n  };\n});\n","import { declare } from \"@babel/helper-plugin-utils\";\nimport * as t from \"@babel/types\";\n\ntype Metadata = {\n  importedLoops: Set<string>;\n  localLoops: Set<string>;\n};\n\n/**\n * babel plugin to auto wrap loops\n *\n * @param api - The babel api.\n * @returns The babel options.\n */\nexport const loopAutoWrapPlugin = declare((api) => {\n  api.assertVersion(7);\n  return {\n    name: \"loop-auto-wrap-plugin\",\n    pre() {\n      // Initialize metadata storage per file\n      const meta = this.file.metadata as Partial<Metadata>;\n      meta.importedLoops = new Set();\n      meta.localLoops = new Set();\n    },\n    visitor: {\n      Program(path, state) {\n        const meta = state.file.metadata as Metadata;\n        const importedLoops = meta.importedLoops;\n        const localLoops = meta.localLoops;\n\n        path.get(\"body\").forEach((child) => {\n          if (child.isImportDeclaration() && child.node.source.value === \"vynn\") {\n            child.node.specifiers.forEach((spec) => {\n              if (t.isImportSpecifier(spec) && t.isIdentifier(spec.imported, { name: \"loop\" })) {\n                importedLoops.add(spec.local.name);\n              }\n            });\n          }\n\n          if (child.isFunctionDeclaration() && t.isIdentifier(child.node.id)) {\n            localLoops.add(child.node.id.name);\n          }\n\n          if (child.isVariableDeclaration()) {\n            child.node.declarations.forEach((decl) => {\n              if (t.isIdentifier(decl.id)) {\n                localLoops.add(decl.id.name);\n              }\n            });\n          }\n        });\n      },\n\n      CallExpression(path, state) {\n        const meta = state.file.metadata as Metadata;\n        const importedLoops = meta.importedLoops;\n        const localLoops = meta.localLoops;\n\n        const callee = path.get(\"callee\");\n        if (!callee.isIdentifier()) return;\n\n        const name = callee.node.name;\n\n        if (importedLoops.has(name) && !localLoops.has(name)) {\n          if (path.node.arguments.length === 1) {\n            const arg = path.node.arguments[0];\n            if (!t.isArrowFunctionExpression(arg) && t.isExpression(arg)) {\n              path.node.arguments[0] = t.arrowFunctionExpression([], arg);\n            }\n          }\n        }\n      },\n    },\n  };\n});\n","import { declare } from \"@babel/helper-plugin-utils\";\nimport { NodePath } from \"@babel/traverse\";\nimport * as t from \"@babel/types\";\n\nexport const wrapJsxChildrenPlugin = declare((api) => {\n  api.assertVersion(7);\n\n  function wrapChildren(path: NodePath<t.JSXElement | t.JSXFragment>) {\n    const processedChildren: t.Expression[] = [];\n\n    path.node.children.forEach((child, i) => {\n      if (t.isJSXText(child)) {\n        let value = child.value;\n\n        if (!value.includes(\"\\n\") || value.trim() !== \"\") {\n          if (i === 0) value = value.trimStart();\n          if (i === path.node.children.length - 1) value = value.trimEnd();\n\n          // wrap text child in a pure arrow function\n          processedChildren.push(\n            t.addComment(\n              t.arrowFunctionExpression([], t.stringLiteral(value)),\n              \"leading\",\n              \"#__PURE__\",\n            ),\n          );\n        }\n      } else if (t.isJSXElement(child) || t.isJSXFragment(child)) {\n        // wrap JSX element/fragment in a pure arrow function\n        processedChildren.push(\n          t.addComment(t.arrowFunctionExpression([], child), \"leading\", \"#__PURE__\"),\n        );\n      } else if (t.isJSXExpressionContainer(child) && !t.isJSXEmptyExpression(child.expression)) {\n        const expr = child.expression;\n\n        if (t.isStringLiteral(expr)) {\n          processedChildren.push(expr);\n        } else {\n          // wrap expression in a pure arrow function\n          processedChildren.push(\n            t.addComment(t.arrowFunctionExpression([], expr), \"leading\", \"#__PURE__\"),\n          );\n        }\n      }\n    });\n\n    if (processedChildren.length === 0) return;\n\n    let body =\n      processedChildren.length === 1 ? processedChildren[0] : t.arrayExpression(processedChildren);\n\n    if (!t.isArrowFunctionExpression(body)) {\n      body = t.addComment(t.arrowFunctionExpression([], body), \"leading\", \"#__PURE__\");\n    }\n\n    path.node.children = [t.jsxExpressionContainer(body)];\n  }\n\n  return {\n    name: \"wrap-jsx-children-plugin\",\n    visitor: {\n      JSXElement(path) {\n        wrapChildren(path);\n      },\n      JSXFragment(path) {\n        wrapChildren(path);\n      },\n    },\n  };\n});\n","import { declare } from \"@babel/helper-plugin-utils\";\nimport { NodePath } from \"@babel/traverse\";\nimport * as t from \"@babel/types\";\n\nexport const wrapJsxExpressionsPlugin = declare((api) => {\n  api.assertVersion(7);\n\n  return {\n    name: \"wrap-jsx-expression-plugin\",\n    visitor: {\n      JSXOpeningElement(path) {\n        const attributes = path.node.attributes;\n\n        const newAttributes = attributes.map((attr) => {\n          if (!t.isJSXAttribute(attr) || !attr.value) return attr;\n\n          const attrName = t.isJSXIdentifier(attr.name) ? attr.name.name : null;\n\n          // Special handling for ref={myRef}\n          if (\n            attrName === \"ref\" &&\n            t.isJSXExpressionContainer(attr.value) &&\n            t.isIdentifier(attr.value.expression)\n          ) {\n            const myRef = attr.value.expression;\n            const elemParam = t.identifier(\"elem\");\n            const assignment = t.assignmentExpression(\"=\", myRef, elemParam);\n\n            const wrappedRef = t.addComment(\n              t.arrowFunctionExpression([elemParam], assignment),\n              \"leading\",\n              \"#__PURE__\",\n            );\n\n            return t.jsxAttribute(t.jsxIdentifier(attrName), t.jsxExpressionContainer(wrappedRef));\n          }\n\n          let propValue: t.Expression | null = null;\n\n          if (t.isStringLiteral(attr.value)) {\n            propValue = attr.value;\n          } else if (t.isJSXExpressionContainer(attr.value)) {\n            if (!t.isJSXEmptyExpression(attr.value.expression)) {\n              propValue = attr.value.expression;\n            }\n          }\n\n          if (propValue === null || attrName === null) return attr;\n\n          const wrappedFn = t.addComment(\n            t.arrowFunctionExpression([], propValue),\n            \"leading\",\n            \"#__PURE__\",\n          );\n\n          return t.jsxAttribute(t.jsxIdentifier(attrName), t.jsxExpressionContainer(wrappedFn));\n        });\n\n        path.node.attributes = newAttributes;\n      },\n\n      JSXExpressionContainer(path: NodePath<t.JSXExpressionContainer>) {\n        const expr = path.node.expression;\n\n        // Skip if it's empty, function, arrow, or literal\n        if (\n          t.isJSXEmptyExpression(expr) ||\n          t.isFunction(expr) ||\n          t.isArrowFunctionExpression(expr) ||\n          t.isLiteral(expr)\n        ) {\n          return;\n        }\n\n        // Wrap expression in a pure arrow function\n        const wrapped = t.addComment(t.arrowFunctionExpression([], expr), \"leading\", \"#__PURE__\");\n\n        path.replaceWith(t.jsxExpressionContainer(wrapped));\n      },\n    },\n  };\n});\n","import { declare } from \"@babel/helper-plugin-utils\";\nimport * as t from \"@babel/types\";\n\nfunction containsJSX(node: t.Node | null | undefined): boolean {\n  if (!node) return false;\n  if (t.isJSXElement(node) || t.isJSXFragment(node)) return true;\n  if (t.isConditionalExpression(node)) {\n    return containsJSX(node.consequent) || containsJSX(node.alternate);\n  }\n  if (t.isLogicalExpression(node)) {\n    return containsJSX(node.left) || containsJSX(node.right);\n  }\n  if (t.isArrayExpression(node)) {\n    return node.elements.some((el) =>\n      el && !t.isSpreadElement(el) ? containsJSX(el as t.Node) : false,\n    );\n  }\n  return false;\n}\n\nexport const wrapJsxVariables = declare((api) => {\n  api.assertVersion(7);\n\n  return {\n    name: \"wrap-jsx-variables\",\n    visitor: {\n      VariableDeclarator(path) {\n        const init = path.node.init;\n        if (!init) return;\n\n        if (containsJSX(init) && !t.isArrowFunctionExpression(init)) {\n          path.node.init = t.arrowFunctionExpression([], init);\n        }\n      },\n      AssignmentExpression(path) {\n        const right = path.node.right;\n        if (containsJSX(right) && !t.isArrowFunctionExpression(right)) {\n          path.node.right = t.arrowFunctionExpression([], right);\n        }\n      },\n    },\n  };\n});\n","import { declare } from \"@babel/helper-plugin-utils\";\nimport * as t from \"@babel/types\";\n\nexport const pureJsxCallsPlugin = declare((api) => {\n  api.assertVersion(7);\n\n  return {\n    name: \"pure-jsx-calls-plugin\",\n    visitor: {\n      CallExpression(path) {\n        const callee = path.node.callee;\n\n        if (t.isIdentifier(callee) && (callee.name === \"_jsx\" || callee.name === \"_jsxs\")) {\n          // Mark the call as PURE\n          t.addComment(path.node, \"leading\", \"#__PURE__\");\n        }\n      },\n    },\n  };\n});\n","import { ConfigAPI, TransformOptions } from \"@babel/core\";\n// @ts-expect-error - babel-preset-react is not typed\nimport jsxTransformPlugin from \"@babel/plugin-transform-react-jsx\";\n\nimport {\n  logJsxPlugin,\n  loopAutoWrapPlugin,\n  wrapJsxChildrenPlugin,\n  wrapJsxExpressionsPlugin,\n  wrapJsxVariables,\n} from \"./plugins\";\nimport { pureJsxCallsPlugin } from \"./plugins/wrap-pure-jsx\";\n\ntype BabelPresetVynnOptions = {\n  ssr: boolean;\n};\n\n/**\n * babel preset for vynn\n *\n * @param api - The babel api.\n * @returns The babel options.\n */\nexport default function babelPresetVynn(\n  api: ConfigAPI,\n  opts: BabelPresetVynnOptions = { ssr: false },\n): TransformOptions {\n  api.assertVersion(7);\n\n  return {\n    plugins: [\n      [\n        jsxTransformPlugin,\n        {\n          runtime: \"automatic\",\n          importSource: !opts.ssr ? \"vynn\" : \"vynn/server\",\n          jsx: \"preserve\",\n        },\n      ],\n      logJsxPlugin,\n      wrapJsxVariables,\n      loopAutoWrapPlugin,\n      wrapJsxChildrenPlugin,\n      wrapJsxExpressionsPlugin,\n      pureJsxCallsPlugin,\n    ],\n  };\n}\n"],"names":["__dirname","path","fileURLToPath","logJsxPlugin","declare","api","babelPath","state","hasLogJsx","child","spec","t","imported","importDecl","callee","newArgs","arg","i","loopAutoWrapPlugin","meta","importedLoops","localLoops","decl","name","wrapJsxChildrenPlugin","wrapChildren","processedChildren","value","expr","body","wrapJsxExpressionsPlugin","newAttributes","attr","attrName","myRef","elemParam","assignment","wrappedRef","propValue","wrappedFn","wrapped","containsJSX","node","el","wrapJsxVariables","init","right","pureJsxCallsPlugin","babelPresetVynn","opts","jsxTransformPlugin"],"mappings":"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"}