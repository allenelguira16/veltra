{"version":3,"file":"h-Bprk7Rnf.js","sources":["../../../src/context/create-state-context.ts","../../../src/context/runtime-context.ts","../../../src/reactivity/effect.ts","../../../src/reactivity/track.ts","../../../src/reactivity/state.ts","../../../src/reactivity/untrack.ts","../../../src/render/dom/event-registry.ts","../../../src/render/dom/apply-props.ts","../../../src/util/create-target-node.ts","../../../src/util/is-node-nil.ts","../../../src/util/log-jsx.ts","../../../src/util/memo.ts","../../../src/util/to-array.ts","../../../src/util/index.ts","../../../src/lifecycle/component-cleanup.ts","../../../src/lifecycle/create-lifecycle.ts","../../../src/lifecycle/on-destroy.ts","../../../src/lifecycle/on-mount.ts","../../../src/lifecycle/run-lifecycle.ts","../../../src/component/async/suspense.ts","../../../src/component/fragment.ts","../../../src/jsx-runtime.ts","../../../src/component/loop/loop.ts","../../../src/component/portal.ts","../../../src/render/get-node.ts","../../../src/render/dom/render-children.ts","../../../src/render/mount-component/resolve-component-props.ts","../../../src/render/mount-component/mount-component.ts","../../../src/render/ssr-dom.ts","../../../src/render/h.ts"],"sourcesContent":["const stateMap = new Map<string, { states: any[] }>();\n\n/**\n * Creates a state context associated with a specific component key\n * Useful for rendering arrays that does not use loop\n *\n * It is still recommended to use loop over normal arrays\n *\n * @param key unique key for string\n */\nexport const createStateContext = (key?: string) => {\n  let instance: { states: any[] };\n\n  if (key !== undefined) {\n    if (!stateMap.has(key)) {\n      stateMap.set(key, { states: [] });\n    }\n    instance = stateMap.get(key)!;\n  } else {\n    instance = { states: [] };\n  }\n\n  return { ...instance, index: 0 };\n};\n","import { DestroyFn, MountFn } from \"~/lifecycle\";\nimport { EffectFn, State } from \"~/reactivity\";\n\nexport interface RuntimeContext {\n  id: string;\n  mount: MountFn[];\n  effect: EffectFn[];\n  state: {\n    states: State<any>[];\n    index: number;\n  };\n  destroy: DestroyFn[];\n}\n\nlet runtimeContext: RuntimeContext | null = null;\n\nexport function setRuntimeContext(ctx: RuntimeContext | null) {\n  runtimeContext = ctx;\n}\n\nexport function getRuntimeContext(): RuntimeContext | null {\n  return runtimeContext;\n}\n","import { getRuntimeContext } from \"~/context\";\n\n/**\n * Effect function type with dependency tracking and cleanup\n */\nexport type EffectFn = (() => Promise<void>) & {\n  deps?: Set<EffectFn>[];\n  cleanup?: () => void;\n};\n\nexport let activeEffect: EffectFn | null = null;\n\nexport function setActiveEffect(newActiveEffect: EffectFn | null) {\n  activeEffect = newActiveEffect;\n}\n\nlet lastDisposer: (() => void) | null = null;\n\n/**\n * Effect scheduling queue\n */\nconst effectQueue = new Set<EffectFn>();\nlet isFlushing = false;\n\nexport function scheduleEffect(effect: EffectFn) {\n  effectQueue.add(effect);\n  if (!isFlushing) {\n    isFlushing = true;\n    queueMicrotask(() => {\n      for (const effect of effectQueue) {\n        effect();\n      }\n      effectQueue.clear();\n      isFlushing = false;\n    });\n  }\n}\n\n/**\n * Create an effect with an attached render frame\n */\nexport function effect(fn: (() => void | (() => void)) | (() => Promise<void | (() => void)>)) {\n  const context = getRuntimeContext();\n  const wrappedEffect: EffectFn = async () => {\n    removeEffect(wrappedEffect);\n\n    // Cleanup previous effect if any\n    if (wrappedEffect.cleanup) {\n      wrappedEffect.cleanup();\n      wrappedEffect.cleanup = undefined;\n    }\n\n    const previousEffect = activeEffect;\n\n    activeEffect = wrappedEffect;\n\n    if (context) context.effect.push(wrappedEffect);\n\n    try {\n      const result = fn();\n      if (typeof result === \"function\") {\n        wrappedEffect.cleanup = result;\n      } else if (result instanceof Promise) {\n        const cleanup = await result;\n        if (typeof cleanup === \"function\") {\n          wrappedEffect.cleanup = cleanup;\n        }\n      }\n    } finally {\n      activeEffect = previousEffect;\n    }\n  };\n\n  const disposer = () => removeEffect(wrappedEffect);\n  lastDisposer = disposer;\n\n  wrappedEffect.deps = [];\n\n  wrappedEffect();\n\n  return disposer;\n}\n\nexport function stopEffect() {\n  if (lastDisposer) {\n    lastDisposer();\n    lastDisposer = null;\n  }\n}\n\n/**\n * Remove an effect and run its cleanup\n */\nexport function removeEffect(effect: EffectFn) {\n  if (effect.deps) {\n    for (const depSet of effect.deps) {\n      depSet.delete(effect);\n    }\n    effect.deps.length = 0;\n  }\n\n  if (effect.cleanup) {\n    effect.cleanup();\n    effect.cleanup = undefined;\n  }\n}\n","import { activeEffect, EffectFn, scheduleEffect } from \"./effect\";\n\n/**\n * WeakMap to track which targets/keys map to which effects\n */\nconst targetToPropertyEffectsMap: WeakMap<object, Map<PropertyKey, Set<EffectFn>>> = new WeakMap();\n\n/**\n * Track a property\n *\n * @param target - The target object.\n * @param key - The property key.\n */\nexport function track(target: object, key: PropertyKey) {\n  if (!activeEffect) return;\n\n  let propertyEffectsMap = targetToPropertyEffectsMap.get(target);\n  if (!propertyEffectsMap) {\n    propertyEffectsMap = new Map();\n    targetToPropertyEffectsMap.set(target, propertyEffectsMap);\n  }\n\n  let effects = propertyEffectsMap.get(key);\n  if (!effects) {\n    effects = new Set();\n    propertyEffectsMap.set(key, effects);\n  }\n\n  if (!effects.has(activeEffect)) {\n    effects.add(activeEffect);\n    // Record this dependency set for cleanup later\n    if (activeEffect.deps) {\n      activeEffect.deps.push(effects);\n    } else {\n      activeEffect.deps = [effects];\n    }\n  }\n}\n\n/**\n * Trigger a property\n *\n * @param target - The target object.\n * @param key - The property key.\n */\nexport function trigger(target: object, key: PropertyKey) {\n  const propertyEffectsMap = targetToPropertyEffectsMap.get(target);\n  if (!propertyEffectsMap) return;\n\n  const effects = propertyEffectsMap.get(key);\n  if (!effects) return;\n\n  for (const effect of effects) {\n    scheduleEffect(effect);\n  }\n}\n","import { getRuntimeContext } from \"~/context\";\n\nimport { track, trigger } from \"./track\";\n\nexport type State<T> = { value: T };\n\n/**\n * Create a state\n *\n * @param initialValue - The initial value of the state.\n * @returns The state object.\n */\nexport function state<T>(initialValue: T): State<T>;\nexport function state<T = undefined>(): State<T | undefined>;\nexport function state<T>(initialValue?: T): State<T | undefined> {\n  const context = getRuntimeContext();\n  if (context && context.state) {\n    const { states, index } = context.state;\n    if (states.length <= index) {\n      // Create new state if it doesn't exist\n      const s = createState(initialValue);\n      states.push(s);\n    }\n    // Return existing state and increment index\n    return states[context.state.index++];\n  }\n  // fallback: not in a component context\n  return createState(initialValue);\n}\n\nfunction createState<T>(initialValue?: T): State<T | undefined> {\n  const state = { value: initialValue };\n\n  return new Proxy(state, {\n    get(target, key, receiver) {\n      track(target, key);\n      return Reflect.get(target, key, receiver);\n    },\n    set(target, key, newValue, receiver) {\n      const oldValue = target[key as keyof typeof target];\n      const result = Reflect.set(target, key, newValue, receiver);\n\n      if (oldValue !== newValue) {\n        trigger(target, key);\n      }\n\n      return result;\n    },\n  });\n}\n","import { activeEffect, setActiveEffect } from \"./effect\";\n\n/**\n * Unwrap a reactive value\n *\n * @param fn - The function that returns the reactive value.\n * @returns The reactive value.\n */\nexport function untrack<T>(fn: () => T): T {\n  const prevEffect = activeEffect;\n  setActiveEffect(null); // disable tracking\n\n  try {\n    return fn();\n  } finally {\n    setActiveEffect(prevEffect); // restore previous tracking context\n  }\n}\n","type EventHandlerMap = Map<string, EventListener>;\n\nconst eventRegistry = new WeakMap<HTMLElement, EventHandlerMap>();\n\n/**\n * Add an event listener\n *\n * @param element - The element to add the event listener to.\n * @param type - The type of event to listen for.\n * @param listener - The event listener function.\n */\nexport function addEventListener(element: HTMLElement, type: string, listener: EventListener) {\n  let handlers = eventRegistry.get(element);\n\n  if (!handlers) {\n    handlers = new Map();\n    eventRegistry.set(element, handlers);\n  }\n\n  // Remove old listener if any\n  if (handlers.has(type)) {\n    element.removeEventListener(type, handlers.get(type)!);\n  }\n\n  element.addEventListener(type, listener);\n  handlers.set(type, listener);\n}\n\n/**\n * Remove an event listener\n *\n * @param element - The element to remove the event listener from.\n * @param type - The type of event to remove.\n */\nexport function removeEventListener(element: HTMLElement, type: string) {\n  const handlers = eventRegistry.get(element);\n  if (!handlers) return;\n\n  const listener = handlers.get(type);\n  if (listener) {\n    element.removeEventListener(type, listener);\n    handlers.delete(type); // Remove it from the map\n  }\n\n  // Clean up if no handlers left\n  if (handlers.size === 0) {\n    eventRegistry.delete(element);\n  }\n}\n\n/**\n * Copy event listeners from one element to another\n *\n * @param from - The element to copy the event listeners from.\n * @param to - The element to copy the event listeners to.\n */\nexport function copyEventListeners(from: HTMLElement, to: HTMLElement) {\n  const handlers = eventRegistry.get(from);\n  if (!handlers) return;\n\n  handlers.forEach((listener, type) => {\n    removeEventListener(to, type);\n    addEventListener(to, type, listener);\n  });\n}\n\n/**\n * Remove all event listeners from an element\n *\n * @param element - The element to remove the event listeners from.\n */\nexport function removeEventListeners(element: HTMLElement) {\n  const handlers = eventRegistry.get(element);\n  if (!handlers) return;\n\n  handlers.forEach((listener, type) => {\n    element.removeEventListener(type, listener);\n  });\n\n  eventRegistry.delete(element);\n}\n","import { effect } from \"~/reactivity\";\n\nimport { addEventListener, removeEventListener } from \"./event-registry\";\n\n/**\n * apply the properties to the element\n *\n * @param element - The element to apply the properties to.\n * @param props - The properties to apply.\n */\nexport function applyProps(element: Element, props: Record<string, any>) {\n  for (const key in props) {\n    effect(() => {\n      const raw = props[key];\n      const value = typeof raw === \"function\" && key !== \"ref\" ? raw() : raw;\n\n      // Event listeners\n      if (key.startsWith(\"on\") && element instanceof HTMLElement) {\n        const type = key.slice(2).toLowerCase();\n        addEventListener(element, type, value);\n        return () => removeEventListener(element, type);\n      }\n\n      // Controlled form elements: <input>, <textarea>, <select>\n      const isFormControl =\n        element instanceof HTMLInputElement ||\n        element instanceof HTMLTextAreaElement ||\n        element instanceof HTMLSelectElement;\n\n      if (\n        key === \"value\" &&\n        isFormControl &&\n        typeof props[\"onInput\"] !== \"function\" &&\n        typeof props[\"onChange\"] !== \"function\"\n      ) {\n        // Force revert if no handler is present\n        element.value = value;\n\n        const revert = () => {\n          if (element.value !== value) {\n            element.value = value;\n          }\n        };\n\n        element.setAttribute(key, value);\n        element.addEventListener(\"input\", revert);\n        return () => element.removeEventListener(\"input\", revert);\n      }\n\n      // Ref\n      if (key === \"ref\" && typeof value === \"function\") {\n        value(element);\n        return;\n      }\n\n      // Style\n      if (key === \"style\" && typeof value === \"object\" && element instanceof HTMLElement) {\n        applyStyle(element, value);\n        return;\n      }\n\n      // Boolean attributes\n      if (typeof value === \"boolean\") {\n        element.toggleAttribute(key, value);\n        return;\n      }\n\n      if (key === \"html\" && typeof value === \"string\") {\n        // Set inner HTML\n        element.innerHTML = value;\n        return;\n      }\n\n      // Default attribute handling\n      element.setAttribute(key, value);\n    });\n  }\n}\n\nfunction isUnitlessProp(prop: string): boolean {\n  // test if \"0\" without unit is valid\n  return CSS.supports(prop, \"0\") && !CSS.supports(prop, \"0px\");\n}\n\n/**\n * apply the style to the element\n *\n * @param element - The element to apply the style to.\n * @param style - The style to apply.\n */\nfunction applyStyle(element: HTMLElement, style: Partial<CSSStyleDeclaration>) {\n  if (!(element instanceof HTMLElement)) return;\n\n  for (const key in style) {\n    if (!Object.hasOwn(style, key)) continue;\n\n    const value = style[key];\n    if (value == null) continue;\n\n    if (key === \"length\" || key === \"parentRule\") continue;\n\n    const isNumeric = typeof value === \"number\";\n    const needsUnit = isNumeric && !isUnitlessProp(key);\n\n    element.style[key] = isNumeric ? (needsUnit ? `${value}px` : `${value}`) : String(value);\n  }\n}\n","import { rootNodes } from \"~/render\";\n\nexport function createTargetNode(name: string) {\n  let targetNode: ChildNode;\n\n  if (process.env.NODE_ENV === \"development\") {\n    targetNode = document.createComment(toKebabCase(name));\n  } else {\n    targetNode = document.createTextNode(\"\");\n  }\n\n  rootNodes.add(targetNode);\n\n  return targetNode;\n}\n\nfunction toKebabCase(str: string) {\n  return str\n    .replace(/([a-z0-9])([A-Z])/g, \"$1-$2\") // insert hyphen before capital letters\n    .replace(/([A-Z])([A-Z][a-z])/g, \"$1-$2\") // handle consecutive capitals (e.g., \"XMLHttpRequest\")\n    .toLowerCase();\n}\n","/**\n * check if a value is null, undefined, or false\n *\n * @param value - The value to check if it is null, undefined, or false.\n * @returns True if the value is null, undefined, or false.\n */\nexport const isNil = (value: unknown): value is null | undefined | false => {\n  return value === undefined || value === null || value === false;\n};\n","import { JSX } from \"~/jsx-runtime\";\nimport { renderChildren, rootNodes } from \"~/render\";\nimport { isServer } from \"~/util\";\n\n/**\n * log the JSX elements\n *\n * @param nodes - The nodes to log.\n * @returns The nodes that are not text nodes and are not in the componentRootNodes set.\n */\nexport function logJsx(nodes: JSX.Element) {\n  if (isServer) return nodes;\n\n  const fragment = document.createDocumentFragment();\n  renderChildren(fragment, nodes);\n\n  const newNodes = [...Array.from(fragment.childNodes).filter((node) => !rootNodes.has(node))];\n\n  return newNodes.length === 1 ? newNodes[0] : newNodes;\n}\n","/**\n * memoize a function\n *\n * @param fn - The function to memoize.\n * @returns The memoized function.\n */\nexport function memo<T>(fn: (...args: any[]) => T) {\n  let cachedResult: T;\n  let firstRun = true;\n\n  return (...args: any[]) => {\n    if (firstRun) {\n      cachedResult = fn(...args);\n      firstRun = false;\n    }\n    return cachedResult;\n  };\n}\n","/**\n * convert an item to an array\n *\n * @param item - The item to convert to an array.\n * @returns The item as an array.\n */\nexport const toArray = <T>(item: T) => {\n  return (Array.isArray(item) ? item : [item]).flat(Infinity) as T[];\n};\n\n/**\n * convert an item to an array\n *\n * @param item - The item to convert to an array.\n * @returns The item as an array.\n */\nexport const flattenArray = <T>(items: T[]) => {\n  return items.flat(Infinity) as T[];\n};\n","export * from \"./component-cache\";\nexport * from \"./create-target-node\";\nexport * from \"./is-node-nil\";\nexport * from \"./log-jsx\";\nexport * from \"./memo\";\nexport * from \"./on-node-reattached\";\nexport * from \"./to-array\";\nexport * from \"./unwrap\";\nexport const isServer = typeof window === \"undefined\";\n","const cleanupMap = new Map<Node, (() => void)[]>();\n\n/**\n * set the component cleanup\n *\n * @param node - The node.\n * @param cleanups - The cleanups.\n */\nexport function setComponentCleanup(node: Node, cleanups: (() => void)[]) {\n  cleanupMap.set(node, cleanups);\n}\n\n/**\n * run the component cleanup\n *\n * @param node - The node.\n */\nexport function runComponentCleanup(node: Node) {\n  // Cleanup for the current node\n  const cleanups = cleanupMap.get(node);\n  if (cleanups) {\n    for (const cleanup of cleanups) {\n      cleanup();\n    }\n    cleanupMap.delete(node);\n  }\n\n  // Recursively clean child nodes\n  for (const child of node.childNodes) {\n    runComponentCleanup(child);\n  }\n}\n","import { createStateContext, RuntimeContext } from \"~/context\";\n\n/**\n * Creates a lifecycle context for managing component lifecycle events.\n *\n * @param key - The key for the lifecycle context, used to associate state with a specific component instance.\n * @returns LifecycleContext - The created lifecycle context.\n */\nexport function createLifeCycleContext(key?: string) {\n  const context: RuntimeContext = {\n    id: crypto.randomUUID(),\n    mount: [],\n    state: createStateContext(key),\n    effect: [],\n    destroy: [],\n  };\n\n  return context;\n}\n","import { getRuntimeContext } from \"~/context\";\nimport { isServer } from \"~/util\";\n\nexport type DestroyFn = () => Promise<void> | void;\n\n/**\n * on destroy\n *\n * @param fn - The function to run on destroy.\n */\nexport function onDestroy(fn: DestroyFn) {\n  if (isServer) return;\n\n  const context = getRuntimeContext();\n  if (!context) {\n    throw new Error(\"onDestroy called outside of component\");\n  }\n\n  context.destroy.push(fn);\n}\n","import { getRuntimeContext } from \"~/context\";\nimport { isServer } from \"~/util\";\n\nimport { DestroyFn } from \"./on-destroy\";\n\nexport type MountFn = () => Promise<void | DestroyFn> | (void | DestroyFn);\n\n/**\n * on mount\n *\n * @param fn - The function to run on mount.\n */\nexport function onMount(fn: () => Promise<DestroyFn> | DestroyFn): void;\nexport function onMount(fn: () => Promise<void> | void): void;\nexport function onMount(fn: MountFn): void {\n  if (isServer) return;\n\n  const context = getRuntimeContext();\n  if (!context) {\n    throw new Error(\"onMount called outside of component\");\n  }\n\n  context.mount.push(fn);\n}\n","import { RuntimeContext } from \"~/context\";\nimport { removeEffect } from \"~/reactivity\";\n\nimport { setComponentCleanup } from \"./component-cleanup\";\n\n/**\n * run the life cycle\n *\n * @param context - The lifecycle context.\n * @param targetNode - The target node.\n */\nexport function runLifecycle(rootNode: Node, context: RuntimeContext) {\n  if (!context) return;\n\n  const cleanups: (() => Promise<void> | void)[] = [];\n  setComponentCleanup(rootNode, cleanups);\n\n  const runMounts = async () => {\n    for (const mountFn of context.mount) {\n      const cleanup = await mountFn();\n      if (cleanup) cleanups.push(cleanup);\n    }\n\n    for (const destroyFn of context.destroy) {\n      cleanups.push(destroyFn);\n    }\n\n    for (const effectFn of context.effect) {\n      cleanups.push(() => Promise.resolve(removeEffect(effectFn)));\n    }\n  };\n\n  queueMicrotask(() => Promise.resolve().then(runMounts));\n}\n","import { JSX } from \"~/jsx-runtime\";\nimport { state } from \"~/reactivity\";\nimport { serverRenderedDOM } from \"~/render\";\nimport { isServer } from \"~/util\";\nimport { memo } from \"~/util\";\n\nconst suspenseHandlerStack: ((promise: Promise<void>) => void)[] = [];\nconst suspenseSSRHandlerStack: (() => JSX.Element)[] = [];\n\nexport function getSuspenseHandler() {\n  return suspenseHandlerStack[suspenseHandlerStack.length - 1] as\n    | ((promise: Promise<void>) => void)\n    | undefined;\n}\n\nexport function getSuspenseSSRHandler() {\n  return suspenseSSRHandlerStack[suspenseSSRHandlerStack.length - 1] as (() => void) | undefined;\n}\n\n/**\n * Suspense component\n *\n * @param props - The props of the component.\n * @returns jsx function\n */\nexport function Suspense(props: { fallback?: JSX.Element; children: JSX.Element }) {\n  const { fallback: _fallback, children: _children } = props as unknown as {\n    fallback?: () => JSX.Element;\n    children: () => JSX.Element;\n  };\n\n  const children = memo(() => _children());\n  const fallback = _fallback ? memo(() => _fallback()) : undefined;\n\n  if (isServer) return fallback?.();\n\n  const view = state<() => JSX.Element>(() => fallback?.());\n\n  const ssrHandler = () => {\n    suspenseSSRHandlerStack.pop();\n\n    return fallback?.();\n  };\n\n  const handler = (promise: Promise<void>) => {\n    suspenseHandlerStack.pop();\n\n    queueMicrotask(() => {\n      if (fallback) view.value = fallback;\n    });\n\n    promise.then(() => {\n      withSuspenseRender(children);\n    });\n  };\n\n  const withSuspenseRender = (newView: () => JSX.Element) => {\n    if (isServer) suspenseSSRHandlerStack.push(ssrHandler);\n    else suspenseHandlerStack.push(handler);\n\n    try {\n      view.value = newView;\n    } catch (error) {\n      if (error instanceof Promise) {\n        if (!isServer) handler(error);\n        else\n          view.value = () => {\n            throw error;\n          };\n      } else {\n        throw error;\n      }\n    }\n  };\n\n  function onDoneHydration(fn: () => void) {\n    if (!serverRenderedDOM().isHydrating) {\n      fn();\n      return;\n    }\n    requestAnimationFrame(() => onDoneHydration(fn));\n  }\n\n  try {\n    return () => {\n      return view.value();\n    };\n  } finally {\n    onDoneHydration(() => {\n      withSuspenseRender(children);\n    });\n  }\n}\n","import { JSX } from \"~/types\";\n/**\n * Create a fragment\n *\n * @param children - The children of the fragment.\n * @returns The fragment.\n */\nexport function Fragment({ children }: { children: () => JSX.Element[] }) {\n  return children;\n}\n","import { Fragment } from \"./component\";\nimport { h } from \"./render\";\nimport { type JSX } from \"./types\";\nimport { logJsx } from \"./util\";\n\n/**\n * jsx runtime\n *\n * @param type - The type of the element.\n * @param props - The properties of the element.\n * @param children - The children of the element.\n * @returns The JSX element.\n */\nconst jsx = <T extends Record<string, any> & { children?: (...args: (T | any)[]) => JSX.Element }>(\n  type: string | ((...args: (T | any)[]) => JSX.Element),\n  { children, ...props }: T = {} as T,\n  key?: () => string,\n) => {\n  return h(type, props, children, key) as JSX.Element;\n};\n\nexport { Fragment, type JSX, jsx, jsx as jsxs, logJsx };\n","import { jsx } from \"~/jsx-runtime\";\nimport { effect, State, state } from \"~/reactivity\";\nimport { JSX } from \"~/types\";\nimport { isServer } from \"~/util\";\n\nimport { getSuspenseHandler } from \"../async\";\n\nexport type Entry<T> = {\n  item: T;\n  nodes: Node[];\n  index: { value: number };\n};\n\n/**\n * create a loop component\n *\n * @param items - The items to loop through.\n * @returns The loop component.\n */\nexport function loop<T>(items: T[]) {\n  return {\n    each(children: (item: T, index: State<number>) => JSX.Element) {\n      const each = items as unknown as () => T[];\n      children = children as unknown as [(item: T, index: State<number>) => JSX.Element][0];\n\n      if (isServer) {\n        const renderedItems = each().map((item, i) => children(item, { value: i }));\n\n        return renderedItems;\n      }\n\n      // Use jsx to register it as a component\n      // That way we can use life cycles hooks\n      return jsx(Loop, { each: each, children });\n    },\n  };\n}\n\nexport function Loop<T>({\n  each,\n  children,\n}: {\n  each: () => T[];\n  children: (item: T, index: State<number>) => Node;\n}) {\n  const handler = getSuspenseHandler();\n  const result = state<Node[]>([]); // holds rendered elements\n  const listFn = mapArray(each, children);\n\n  // Reactively update the list whenever props.each() changes\n  effect(() => {\n    try {\n      result.value = listFn();\n    } catch (err) {\n      if (err instanceof Promise && handler) {\n        handler(err); // register promise with Suspense\n      } else {\n        throw err; // real error\n      }\n    }\n  });\n\n  // Return a getter so that the view updates when result changes\n  return () => result.value;\n}\n\nexport function mapArray<T>(\n  list: () => readonly T[],\n  mapFn: (item: T, index: State<number>) => Node,\n) {\n  let items: { index: State<number>; value: T; element: Node }[] = [];\n\n  return () => {\n    const arr = list() || [];\n    const len = arr.length;\n    const newItems = new Array(len);\n    const oldIndexMap = new Map<T, number[]>();\n\n    // Build index map for old items (handle duplicates by storing arrays of indices)\n    for (let i = 0; i < items.length; i++) {\n      const key = items[i].value;\n      if (!oldIndexMap.has(key)) oldIndexMap.set(key, []);\n      oldIndexMap.get(key)!.push(i);\n    }\n\n    // Match new array to old array\n    const newToOld = new Array(len).fill(-1);\n    for (let i = 0; i < len; i++) {\n      const value = arr[i];\n      const oldIndices = oldIndexMap.get(value);\n      if (oldIndices && oldIndices.length) {\n        const oldIndex = oldIndices.shift()!;\n        newToOld[i] = oldIndex;\n        newItems[i] = items[oldIndex];\n      } else {\n        // Create new element if not found\n        const idxState = state(i);\n        const element = mapFn(value, idxState);\n        newItems[i] = { value, index: idxState, element };\n      }\n    }\n\n    // Remove any old items not reused\n    for (let i = 0; i < items.length; i++) {\n      if (!newToOld.includes(i)) {\n        const el = items[i].element;\n        el.parentNode?.removeChild(el);\n      }\n    }\n\n    // Compute LIS to minimize moves\n    const seq = longestIncreasingSubsequence(newToOld);\n\n    // Apply moves in reverse to avoid messing up DOM order\n    let seqIdx = seq.length - 1;\n    for (let i = len - 1; i >= 0; i--) {\n      const item = newItems[i];\n      if (newToOld[i] === -1 || i !== seq[seqIdx]) {\n        // Insert/move node\n        const anchor = i + 1 < len ? newItems[i + 1].element : null;\n        item.element.parentNode?.insertBefore(item.element, anchor);\n      } else {\n        seqIdx--;\n      }\n      item.index.value = i; // update reactive index\n    }\n\n    items = newItems;\n    return items.map((it) => it.element);\n  };\n}\n\nfunction longestIncreasingSubsequence(arr: number[]): number[] {\n  const p = arr.slice();\n  const result: number[] = [];\n  let u: number, v: number;\n\n  for (let i = 0; i < arr.length; i++) {\n    const n = arr[i];\n    if (n < 0) continue;\n    if (result.length === 0 || arr[result[result.length - 1]] < n) {\n      p[i] = result.length > 0 ? result[result.length - 1] : -1;\n      result.push(i);\n      continue;\n    }\n    u = 0;\n    v = result.length - 1;\n    while (u < v) {\n      const c = ((u + v) / 2) | 0;\n      if (arr[result[c]] < n) u = c + 1;\n      else v = c;\n    }\n    if (n < arr[result[u]]) {\n      if (u > 0) p[i] = result[u - 1];\n      result[u] = i;\n    }\n  }\n\n  u = result.length;\n  v = result[u - 1];\n  while (u-- > 0) {\n    result[u] = v;\n    v = p[v];\n  }\n  return result;\n}\n\n// export function Loop<T>({\n//   children,\n//   each,\n//   handler,\n// }: {\n//   each: () => T[];\n//   children: (item: T, index: State<number>) => JSX.Element;\n//   handler: ((promise: Promise<void>) => void) | undefined;\n// }) {\n//   const rootNode = createTargetNode(\"Loop\");\n//   componentRootNodes.add(rootNode);\n\n//   let entries: Entry<T>[] = [];\n\n//   function reconcile(parentNode: Node, items: T[]) {\n//     // Remove extra\n//     entries = removeOldNodes(parentNode, items, entries);\n\n//     // Add new\n//     entries.push(...newEntries(items, entries, children));\n\n//     console.log(entries);\n\n//     reorderEntries(rootNode, parentNode, entries, items);\n//   }\n\n//   const render = () => {\n//     effect(() => {\n//       try {\n//         const parentNode = rootNode.parentNode;\n//         if (!parentNode) return;\n\n//         const list = each();\n//         if (!list) return;\n\n//         reconcile(parentNode, [...list]);\n//       } catch (error) {\n//         if (error instanceof Promise) {\n//           if (handler) {\n//             handler(error);\n//           }\n//         } else {\n//           throw error;\n//         }\n//       }\n//     });\n//   };\n\n//   queueMicrotask(() => {\n//     render();\n//   });\n\n//   onDestroy(() => {\n//     for (const entry of entries) {\n//       removeEntryNodes(rootNode.parentNode!, entry);\n//     }\n//   });\n\n//   return rootNode;\n// }\n","import { onDestroy, onMount } from \"~/lifecycle\";\nimport { renderChildren } from \"~/render\";\nimport { PropsWithChildren } from \"~/types\";\n\n/**\n *\n * @param children The children of the Portal.\n * @param target\n * @returns\n */\nexport function Portal({ children, target }: PropsWithChildren<{ target: Node }>) {\n  let cleanup: () => void;\n\n  onMount(() => {\n    const mount: Node = (target instanceof Function ? target() : target) ?? document.body;\n    cleanup = renderChildren(mount, children);\n  });\n\n  onDestroy(() => {\n    cleanup();\n  });\n\n  return null;\n}\n","import { JSX } from \"~/types\";\nimport { toArray } from \"~/util\";\n\n/**\n * get the node for a JSX element\n *\n * @param jsxElement - The JSX element to get the node for.\n * @returns The node for the JSX element.\n */\nexport function getNode<T extends Node>(jsxElement: JSX.Element): T {\n  if (jsxElement instanceof Node) {\n    return jsxElement as T;\n  }\n\n  if (typeof jsxElement === \"string\" || typeof jsxElement === \"number\") {\n    return document.createTextNode(String(jsxElement)) as unknown as T;\n  }\n\n  throw new Error(`Unknown value: ${jsxElement}`);\n}\n\nexport function getNodes<T extends Node>(jsxElement: JSX.Element) {\n  return toArray(getNode<T>(jsxElement)).flat();\n}\n","import { getSuspenseHandler } from \"~/component\";\nimport { runComponentCleanup } from \"~/lifecycle\";\nimport { effect } from \"~/reactivity\";\nimport { JSX } from \"~/types\";\nimport { isNil, toArray } from \"~/util\";\n\nimport { getNode } from \"../get-node\";\n\n/**\n * Render JSX children recursively into parentNode.\n * Supports arrays, functions, and nested dynamic expressions.\n */\nexport function renderChildren(parentNode: Node, children: JSX.Element) {\n  const cleanups: (() => void)[] = [];\n\n  function renderRecursive(value: JSX.Element, parentAnchor: Node | null): () => void {\n    let nodes: Node[] = [];\n    let disposers: (() => void)[] = [];\n\n    const cleanup = () => {\n      for (const node of nodes) {\n        runComponentCleanup(node);\n        if (node.parentNode === parentNode) {\n          parentNode.removeChild(node);\n        }\n      }\n      for (const dispose of disposers) dispose();\n      nodes = [];\n      disposers = [];\n    };\n\n    const handler = getSuspenseHandler();\n    const disposer = effect(() => {\n      try {\n        cleanup();\n\n        const resolvedChildren = value instanceof Function ? value() : value;\n        const children = toArray(resolvedChildren);\n\n        for (const child of children) {\n          if (isNil(child)) continue;\n\n          if (typeof child === \"function\") {\n            const anchor = document.createTextNode(\"\");\n            parentNode.insertBefore(anchor, parentAnchor);\n\n            const childDisposer = renderRecursive(child, anchor);\n            disposers.push(childDisposer);\n            nodes.push(anchor);\n          } else {\n            const node = getNode(child);\n\n            parentNode.insertBefore(node, parentAnchor);\n            nodes.push(node);\n          }\n        }\n      } catch (error) {\n        if (error instanceof Promise) {\n          handler?.(error);\n        } else {\n          throw error;\n        }\n      }\n    });\n\n    return () => {\n      disposer();\n      cleanup();\n    };\n  }\n\n  const dispose = renderRecursive(children, null);\n  cleanups.push(dispose);\n\n  return () => {\n    console.log(\"run\");\n    for (const c of cleanups) c();\n  };\n}\n","import { Loop, Portal, Suspense } from \"~/component\";\n\nconst IGNORE_COMPONENT = [Suspense, Loop, Portal] as Array<(...args: any[]) => any>;\n\n/**\n * resolve the component props\n *\n * @param type - The type of the component.\n * @param props - The properties of the component.\n */\nexport function resolveComponentProps(type: (...args: any[]) => any, props: Record<string, any>) {\n  if (IGNORE_COMPONENT.includes(type)) return;\n\n  for (const key in props) {\n    props[key] = props[key] instanceof Function ? props[key]() : props[key];\n  }\n}\n","import { setRuntimeContext } from \"~/context\";\nimport { createLifeCycleContext, runComponentCleanup, runLifecycle } from \"~/lifecycle\";\nimport { untrack } from \"~/reactivity\";\nimport { JSX } from \"~/types\";\nimport { isServer } from \"~/util\";\nimport { createTargetNode, toArray } from \"~/util\";\n\nimport { resolveComponentProps } from \"./resolve-component-props\";\n\nexport const rootNodes = new WeakSet<Node>();\nexport const cleanupMap = new WeakMap<Node, (() => Promise<void> | void)[]>();\n\n/**\n * mount a component\n *\n * @param type - The type of the component.\n * @param props - The properties of the component.\n * @param children - The children of the component.\n */\nexport function mountComponent<\n  T extends Record<string, any> & { children?: (...args: any[]) => JSX.Element },\n>(\n  type: (props: T) => JSX.Element,\n  props: Omit<T, \"children\"> = {} as Omit<T, \"children\">,\n  children?: T[\"children\"],\n  _key?: () => string | number,\n) {\n  resolveComponentProps(type, props);\n\n  const key = _key ? _key().toString() + type.toString() : undefined;\n  const context = createLifeCycleContext(key);\n\n  setRuntimeContext(context);\n  const rootNode = createTargetNode(type.name);\n  const jsxElements = toArray([rootNode, untrack(() => type({ ...props, children } as T))]).flat();\n  setRuntimeContext(null);\n\n  runLifecycle(rootNode, context);\n\n  return jsxElements as JSX.Element;\n}\n\nqueueMicrotask(() => {\n  if (!isServer) {\n    const observer = new MutationObserver((mutations) => {\n      for (const mutation of mutations) {\n        for (const removedNodes of mutation.removedNodes) {\n          runComponentCleanup(removedNodes);\n        }\n      }\n    });\n\n    observer.observe(document.body, { childList: true, subtree: true });\n  }\n});\n","import { isServer } from \"~/util\";\n\nlet renderedElement: Element[] = [];\n\nlet currentElementIndex = 0;\n\nexport function serverRenderedDOM() {\n  return {\n    renderedDOM: renderedElement,\n    get currentDOM() {\n      if (isServer) return undefined;\n\n      return renderedElement[currentElementIndex];\n    },\n    get isHydrating() {\n      return currentElementIndex < renderedElement.length;\n    },\n    nextElement: () => currentElementIndex++,\n  };\n}\n\nexport function setServerRenderedDOM(node: Element[]) {\n  renderedElement = node;\n}\n","import { JSX } from \"~/types\";\n\nimport { applyProps, renderChildren } from \"./dom\";\nimport { mountComponent } from \"./mount-component\";\nimport { serverRenderedDOM } from \"./ssr-dom\";\n\n/**\n * create a JSX element\n *\n * @param type - The type of the element.\n * @param props - The properties of the element.\n * @param children - The children of the element.\n * @returns The JSX element.\n */\nexport function h<T extends Record<string, any> & { children?: (...args: any[]) => JSX.Element }>(\n  type: string | ((props: T) => JSX.Element),\n  props: Omit<T, \"children\">,\n  children: T[\"children\"],\n  key?: () => string,\n) {\n  if (typeof type === \"function\") {\n    return mountComponent(type, props, children, key);\n  }\n\n  xmlnsStack.push(props.xmlns?.() ?? xmlnsStack[xmlnsStack.length - 1]);\n\n  const element = createElement(type);\n\n  applyProps(element, props);\n  renderChildren(element, children);\n\n  xmlnsStack.pop();\n  return element;\n}\n\nconst xmlnsStack: (string | undefined)[] = [];\n\nfunction createElement(tag: string) {\n  const { currentDOM, isHydrating, nextElement } = serverRenderedDOM();\n\n  if (isHydrating && currentDOM) {\n    try {\n      if (currentDOM.tagName.toLocaleLowerCase() !== tag) {\n        throw new Error(\n          \"Hydration mismatch because the initial UI does not match what was rendered on the server\",\n        );\n      }\n\n      return currentDOM;\n    } finally {\n      nextElement();\n    }\n  }\n\n  const currentXmlns = xmlnsStack[xmlnsStack.length - 1];\n  return currentXmlns ? document.createElementNS(currentXmlns, tag) : document.createElement(tag);\n}\n"],"names":["stateMap","Map","createStateContext","key","instance","undefined","has","set","states","get","index","runtimeContext","setRuntimeContext","ctx","getRuntimeContext","activeEffect","setActiveEffect","newActiveEffect","lastDisposer","effectQueue","Set","isFlushing","scheduleEffect","effect","add","queueMicrotask","clear","fn","context","wrappedEffect","removeEffect","cleanup","previousEffect","push","result","Promise","disposer","deps","stopEffect","depSet","delete","length","targetToPropertyEffectsMap","WeakMap","track","target","propertyEffectsMap","effects","trigger","state","initialValue","s","createState","value","Proxy","receiver","Reflect","newValue","oldValue","untrack","prevEffect","eventRegistry","addEventListener","element","type","listener","handlers","removeEventListener","size","applyProps","props","raw","startsWith","HTMLElement","slice","toLowerCase","isFormControl","HTMLInputElement","HTMLTextAreaElement","HTMLSelectElement","revert","setAttribute","applyStyle","toggleAttribute","innerHTML","isUnitlessProp","prop","CSS","supports","style","Object","hasOwn","isNumeric","needsUnit","String","createTargetNode","name","targetNode","process","env","NODE_ENV","document","createComment","toKebabCase","createTextNode","rootNodes","str","replace","isNil","logJsx","nodes","isServer","fragment","createDocumentFragment","renderChildren","newNodes","Array","from","childNodes","filter","node","memo","cachedResult","firstRun","args","toArray","item","isArray","flat","Infinity","window","cleanupMap","setComponentCleanup","cleanups","runComponentCleanup","child","createLifeCycleContext","id","crypto","randomUUID","mount","destroy","onDestroy","Error","onMount","runLifecycle","rootNode","runMounts","mountFn","destroyFn","effectFn","resolve","then","suspenseHandlerStack","suspenseSSRHandlerStack","getSuspenseHandler","getSuspenseSSRHandler","Suspense","fallback","_fallback","children","_children","view","ssrHandler","pop","handler","promise","withSuspenseRender","newView","error","onDoneHydration","serverRenderedDOM","isHydrating","requestAnimationFrame","Fragment","jsx","h","loop","items","each","map","i","Loop","listFn","mapArray","err","list","mapFn","arr","len","newItems","oldIndexMap","newToOld","fill","oldIndices","oldIndex","shift","idxState","includes","el","parentNode","removeChild","seq","longestIncreasingSubsequence","seqIdx","anchor","insertBefore","it","p","u","v","n","c","Portal","Function","body","getNode","jsxElement","Node","renderRecursive","parentAnchor","disposers","dispose","resolvedChildren","childDisposer","console","log","IGNORE_COMPONENT","resolveComponentProps","WeakSet","mountComponent","_key","toString","jsxElements","MutationObserver","mutations","mutation","removedNodes","observe","childList","subtree","renderedElement","currentElementIndex","renderedDOM","currentDOM","nextElement","setServerRenderedDOM","xmlnsStack","xmlns","createElement","tag","tagName","toLocaleLowerCase","currentXmlns","createElementNS"],"mappings":"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"}