{"version":3,"file":"index.js","sources":["../../src/context/create-context.ts","../../src/reactivity/computed.ts","../../src/reactivity/store.ts","../../src/util/unwrap.ts","../../src/component/async/lazy.ts","../../src/component/async/resource.ts","../../src/render/create-app.ts","../../src/client/hydrate-app.ts"],"sourcesContent":["import { JSX } from \"~/types\";\n\nconst map = new WeakMap<symbol, any>();\n\n/**\n * Create Context helper\n *\n * @returns Provider and context\n */\nexport function createContext<T>() {\n  const id = Symbol(\"context\");\n\n  function Provider(props: { value: T; children: () => JSX.Element }) {\n    map.set(id, props.value);\n    return props.children();\n  }\n\n  function getContext(): T {\n    const value = map.get(id);\n    if (!value) {\n      throw new Error(\"No provider found for context.\");\n    }\n\n    return value;\n  }\n\n  return [Provider, getContext] as const;\n}\n","import { effect } from \"./effect\";\nimport { state } from \"./state\";\n\nexport type Computed<T> = {\n  readonly value: T;\n};\n\n/**\n * Create a computed value\n *\n * @param getter - The getter function that returns the computed value from a reactive value.\n * @returns The computed value.\n */\nexport function computed<T>(getter: () => T): Computed<T> {\n  const result = state<T>();\n\n  effect(() => {\n    result.value = getter();\n  });\n\n  return {\n    get value() {\n      return result.value as T;\n    },\n  };\n}\n","import { track, trigger } from \"./track\";\n\nexport type Store<T extends object> = T;\n\nconst proxyMap = new WeakMap<object, unknown>();\n\nexport function store<T extends object>(initialObject: T): Store<T> {\n  function createReactiveObject(obj: T): T {\n    if (proxyMap.has(obj)) return proxyMap.get(obj) as T;\n\n    const proxy = new Proxy(obj, {\n      get(target, key, receiver) {\n        // track every property access\n        track(target, key);\n\n        const result = Reflect.get(target, key, receiver);\n\n        // Auto-bind methods to the Proxy itself to avoid 'this' becoming DOM or global\n        if (typeof result === \"function\") {\n          return result.bind(receiver);\n        }\n\n        // Handle getters (derived properties)\n        const descriptor = Reflect.getOwnPropertyDescriptor(target, key);\n        if (descriptor?.get) {\n          return descriptor.get.call(receiver);\n        }\n\n        // Deep reactivity\n        if (typeof result === \"object\" && result !== null) {\n          return createReactiveObject(result as T);\n        }\n\n        return result;\n      },\n\n      set(target, key, value, receiver) {\n        const oldValue = target[key as keyof T];\n        const result = Reflect.set(target, key, value, receiver);\n\n        if (oldValue !== value) {\n          trigger(target, key);\n        }\n\n        return result;\n      },\n    });\n\n    proxyMap.set(obj, proxy);\n    return proxy;\n  }\n\n  return createReactiveObject(initialObject);\n}\n","/**\n * unwraps proxy objects\n *\n * @param value - The value to unwrap.\n * @returns The unwrapped value.\n */\nexport function unwrap<T>(value: any): Partial<T> {\n  function deepUnwrap(obj: any): any {\n    if (obj === null || typeof obj !== \"object\") return obj;\n\n    if (typeof obj === \"function\") return obj;\n\n    const result: any = {};\n    for (const key of Reflect.ownKeys(obj)) {\n      const value = obj[key];\n      result[key] = deepUnwrap(value);\n    }\n    return result;\n  }\n\n  return deepUnwrap(value);\n}\n","import { JSX } from \"~/types\";\nimport { memo } from \"~/util\";\n\n/**\n *\n * @param loader lazy loader import\n * @param namedExport name of the exported\n * @returns jsx\n */\nexport function lazy<M extends Record<string, any>, K extends keyof M = \"default\">(\n  loader: () => Promise<M>,\n  namedExport?: K,\n): () => JSX.Element {\n  let component: M[K] | undefined;\n  let error: Error | undefined;\n  let promise: Promise<void> | null = null;\n\n  const key = namedExport ?? (\"default\" as K);\n\n  // TODO: make ssr compatible make async into sync or similar sync\n  const getComponent = memo((): M[K] => {\n    if (component) return component;\n    if (error) throw error;\n\n    if (!promise) {\n      promise = loader()\n        .then((mod) => {\n          if (!(key in mod)) {\n            throw new Error(`lazy(): Export \"${String(key)}\" not found in module`);\n          }\n          component = mod[key];\n        })\n        .catch((err) => {\n          error = err instanceof Error ? err : new Error(String(err));\n        });\n    }\n\n    throw promise;\n  });\n\n  return () => {\n    const Comp = getComponent();\n    return Comp();\n  };\n}\n","import { onDestroy } from \"~/lifecycle\";\nimport { isServer } from \"~/util\";\n\nimport { effect } from \"../../reactivity/effect\";\nimport { state } from \"../../reactivity/state\";\nimport { untrack } from \"../../reactivity/untrack\";\n\nexport type ResourceReturn<T> = {\n  readonly loading: boolean;\n  readonly error: Error | null;\n  readonly data: T;\n  refetch: () => Promise<void>;\n  mutate: (newValue: T) => void;\n};\n\n/**\n * Create a reactive resource\n *\n * @param fetcher - The function to fetch the data.\n * @returns The resource.\n */\nexport function baseResource<T>(fetcher: () => Promise<T>): ResourceReturn<T> {\n  let loading = true;\n  let error = null as Error | null;\n  let data = undefined as T | undefined;\n  let promise: Promise<T> | null = null;\n  let promiseStatus = \"pending\" as \"pending\" | \"fulfilled\" | \"rejected\";\n\n  const version = state(0);\n\n  const refetch = async () => {\n    loading = true;\n    error = null;\n    data = undefined as T | undefined;\n    promiseStatus = \"pending\";\n    promise = fetcher();\n\n    promise\n      .then((result) => {\n        data = result;\n        error = null;\n        promiseStatus = \"fulfilled\";\n        loading = false;\n        untrack(() => version.value++);\n      })\n      .catch((err) => {\n        data = undefined as T | undefined;\n        error = err;\n        promiseStatus = \"rejected\";\n        loading = false;\n        untrack(() => version.value++);\n      });\n\n    untrack(() => version.value++);\n  };\n\n  effect(() => {\n    refetch();\n  });\n\n  return {\n    get loading() {\n      // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n      version.value;\n      return loading;\n    },\n    get error() {\n      return error;\n    },\n    get data() {\n      // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n      version.value;\n\n      if (promiseStatus === \"pending\") throw promise;\n      if (promiseStatus === \"rejected\") throw error;\n\n      return data as T;\n    },\n    refetch,\n    mutate(newValue: T) {\n      data = newValue;\n      version.value++;\n    },\n  };\n}\n\nconst resourceCache = new Map<string, ResourceReturn<any>>();\n\n/**\n * Create a reactive resource\n *\n * @param fetcher - The function to fetch the data.\n * @returns The resource.\n */\nexport function resource<T>(fetcher: () => Promise<T>, key: string): ResourceReturn<T> {\n  if (isServer) return baseResource(fetcher);\n\n  onDestroy(() => {\n    resourceCache.delete(key);\n  });\n\n  if (resourceCache.has(key)) {\n    return resourceCache.get(key) as ResourceReturn<T>;\n  }\n\n  const resourceFn = baseResource(fetcher);\n  resourceCache.set(key, resourceFn);\n\n  return resourceFn;\n}\n","import { JSX } from \"~/types\";\n\nimport { renderChildren } from \"./dom\";\nimport { mountComponent } from \"./mount-component\";\n/**\n * create root app\n *\n * @param App - The app to render.\n */\nexport function createApp(App: () => JSX.Element) {\n  let cleanup: (() => void) | undefined;\n\n  return {\n    mount: (id: string | HTMLElement) => {\n      let node: HTMLElement | null;\n\n      if (typeof id !== \"string\") node = id;\n      else node = document.querySelector(id);\n\n      if (!(node instanceof HTMLElement)) throw new Error(\"Node must be of type Element\");\n\n      const app = mountComponent(App);\n      cleanup = renderChildren(node, app);\n    },\n    unmount: () => {\n      if (!cleanup) throw new Error(\"Can only unmount if the app is mounted\");\n      cleanup();\n    },\n  };\n}\n","import { mountComponent, renderChildren } from \"~/render\";\nimport { JSX } from \"~/types\";\n\nimport { setServerRenderedDOM } from \"../render/ssr-dom\";\n\n/**\n * create root app\n *\n * @param App - The app to render.\n */\nexport function hydrateApp(App: () => JSX.Element) {\n  let cleanup: (() => void) | undefined;\n\n  return {\n    mount: (id: string | HTMLElement) => {\n      let node: HTMLElement | null;\n\n      if (typeof id !== \"string\") node = id;\n      else node = document.querySelector(id);\n\n      if (!(node instanceof HTMLElement)) throw new Error(\"Node must be of type Element\");\n\n      removeAllTextNodes(node);\n\n      const serverRenderedDOM = flattenDOMContents(node);\n      setServerRenderedDOM(serverRenderedDOM);\n\n      const app = mountComponent(App);\n      cleanup = renderChildren(node, app);\n    },\n    unmount: () => {\n      if (!cleanup) throw new Error(\"Can only unmount if the app is mounted\");\n      cleanup();\n    },\n  };\n}\n\nfunction removeAllTextNodes(node: Node) {\n  // Check if the node is a text node and not purely whitespace\n  if (node instanceof Text && node.textContent.trim() !== \"\") {\n    node.textContent = \"\"; // Set text content to empty string\n  }\n\n  // Recursively call for child nodes\n  for (let i = 0; i < node.childNodes.length; i++) {\n    removeAllTextNodes(node.childNodes[i]);\n  }\n}\n\nfunction flattenDOMContents(root: HTMLElement) {\n  const dom: Element[] = [];\n\n  for (const child of [...root.childNodes]) {\n    // clone array so removal doesn't mess iteration\n    flattenNode(child, dom);\n  }\n\n  return dom;\n}\n\nfunction flattenNode(node: Node, dom: Element[]) {\n  if (node instanceof HTMLElement) {\n    dom.push(node);\n\n    for (const child of [...node.childNodes]) {\n      flattenNode(child, dom);\n    }\n  }\n}\n"],"names":["map","WeakMap","createContext","id","Symbol","Provider","props","set","value","children","getContext","get","Error","computed","getter","result","state","effect","proxyMap","store","initialObject","createReactiveObject","obj","has","proxy","Proxy","target","key","receiver","track","Reflect","bind","descriptor","getOwnPropertyDescriptor","call","oldValue","trigger","unwrap","deepUnwrap","ownKeys","lazy","loader","namedExport","component","error","promise","getComponent","memo","then","mod","String","catch","err","baseResource","fetcher","loading","data","promiseStatus","version","refetch","undefined","untrack","mutate","newValue","resourceCache","Map","resource","isServer","onDestroy","delete","resourceFn","createApp","App","cleanup","mount","node","document","querySelector","HTMLElement","app","mountComponent","renderChildren","unmount","hydrateApp","removeAllTextNodes","serverRenderedDOM","flattenDOMContents","setServerRenderedDOM","Text","textContent","trim","i","childNodes","length","root","dom","child","flattenNode","push"],"mappings":"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"}