import{s as a,e as d,t as b,a as M,m,i as C,o as h,u as i,b as g,r as w,c as N}from"./chunks/h-Bprk7Rnf.js";import{F as O,P as W,S as K,l as $,d as B,f as G}from"./chunks/h-Bprk7Rnf.js";const y=new WeakMap;function R(){const r=Symbol("context");function t(n){return y.set(r,n.value),n.children()}function e(){const n=y.get(r);if(!n)throw new Error("No provider found for context.");return n}return[t,e]}function j(r){const t=a();return d(()=>{t.value=r()}),{get value(){return t.value}}}const p=new WeakMap;function k(r){function t(e){if(p.has(e))return p.get(e);const n=new Proxy(e,{get(o,u,s){M(o,u);const c=Reflect.get(o,u,s);if(typeof c=="function")return c.bind(s);const f=Reflect.getOwnPropertyDescriptor(o,u);return f?.get?f.get.call(s):typeof c=="object"&&c!==null?t(c):c},set(o,u,s,c){const f=o[u],S=Reflect.set(o,u,s,c);return f!==s&&b(o,u),S}});return p.set(e,n),n}return t(r)}function P(r){function t(e){if(e===null||typeof e!="object"||typeof e=="function")return e;const n={};for(const o of Reflect.ownKeys(e)){const u=e[o];n[o]=t(u)}return n}return t(r)}function T(r,t){let e,n,o=null;const u=t??"default",s=m(()=>{if(e)return e;throw n||(o||(o=r().then(c=>{if(!(u in c))throw new Error(`lazy(): Export "${String(u)}" not found in module`);e=c[u]}).catch(c=>{n=c instanceof Error?c:new Error(String(c))})),o)});return()=>s()()}function v(r){let t=!0,e=null,n,o=null,u="pending";const s=a(0),c=async()=>{t=!0,e=null,n=void 0,u="pending",o=r(),o.then(f=>{n=f,e=null,u="fulfilled",t=!1,i(()=>s.value++)}).catch(f=>{n=void 0,e=f,u="rejected",t=!1,i(()=>s.value++)}),i(()=>s.value++)};return d(()=>{c()}),{get loading(){return s.value,t},get error(){return e},get data(){if(s.value,u==="pending")throw o;if(u==="rejected")throw e;return n},refetch:c,mutate(f){n=f,s.value++}}}const l=new Map;function D(r,t){if(C)return v(r);if(h(()=>{l.delete(t)}),l.has(t))return l.get(t);const e=v(r);return l.set(t,e),e}function H(r){let t;return{mount:e=>{let n;if(typeof e!="string"?n=e:n=document.querySelector(e),!(n instanceof HTMLElement))throw new Error("Node must be of type Element");const o=g(r);t=w(n,o)},unmount:()=>{if(!t)throw new Error("Can only unmount if the app is mounted");t()}}}function L(r){let t;return{mount:e=>{let n;if(typeof e!="string"?n=e:n=document.querySelector(e),!(n instanceof HTMLElement))throw new Error("Node must be of type Element");E(n);const o=q(n);N(o);const u=g(r);t=w(n,u)},unmount:()=>{if(!t)throw new Error("Can only unmount if the app is mounted");t()}}}function E(r){r instanceof Text&&r.textContent.trim()!==""&&(r.textContent="");for(let t=0;t<r.childNodes.length;t++)E(r.childNodes[t])}function q(r){const t=[];for(const e of[...r.childNodes])x(e,t);return t}function x(r,t){if(r instanceof HTMLElement){t.push(r);for(const e of[...r.childNodes])x(e,t)}}export{O as Fragment,W as Portal,K as Suspense,j as computed,H as createApp,R as createContext,d as effect,L as hydrateApp,T as lazy,$ as loop,m as memo,h as onDestroy,B as onMount,D as resource,a as state,G as stopEffect,k as store,i as untrack,P as unwrap};
//# sourceMappingURL=index.js.map
