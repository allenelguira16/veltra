{"version":3,"file":"parse-route-Dv6iTiKO.js","sources":["../../src/parse-route.tsx"],"sourcesContent":["import fileRoutes, { RouteModule } from \"vinxi/routes\";\nimport { JSX } from \"vynn\";\nimport { Route } from \"vynn-router\";\n\nfunction buildRouteTree() {\n  function buildNode(route: RouteModule, all: RouteModule[]): Route {\n    const $layout = route.$$layout;\n    const $component = route.$$component;\n\n    const Layout: (() => JSX.Element) | undefined = $layout?.require().default;\n    const Component: (() => JSX.Element) | undefined = $component?.require().default;\n\n    // always create a node for the route (parent grouping)\n    const node: Route = {\n      path: route.path,\n      children: [],\n    };\n\n    // find direct children (one level deeper)\n    const directChildren = all.filter((r) => {\n      if (r.path === route.path) return false;\n      if (!r.path.startsWith(route.path === \"/\" ? \"/\" : route.path + \"/\")) return false;\n\n      const rest = r.path.slice(route.path === \"/\" ? 1 : route.path.length + 1);\n      return !rest.includes(\"/\");\n    });\n\n    // If there's a layout -> parent must render the layout (keeps Outlet)\n    if (Layout) {\n      node.component = Layout;\n      // if there's also a page component (page + layout), nest it at \"/\"\n      if (Component) {\n        node.children!.push({\n          path: \"/\",\n          component: Component,\n        });\n      }\n    } else {\n      // No layout:\n      // - If there's a component and NO direct children => leaf route: parent becomes that component\n      // - If there's a component and there ARE direct children => move the component into children as \"/\"\n      if (Component) {\n        if (directChildren.length === 0) {\n          node.component = Component;\n        } else {\n          // Move page into children as \"/\"\n          node.children!.push({\n            path: \"/\",\n            component: Component,\n          });\n        }\n      }\n      // If no component and no layout -> parent is just a grouping node (no component)\n    }\n\n    // Recurse direct children and normalize child paths relative to parent\n    for (const child of directChildren) {\n      const childNode = buildNode(child, all);\n\n      // childNode.path is absolute (e.g. \"/test/test\").\n      // We want it relative to parent:\n      // - if equal to parent => \"/\"\n      // - else remove parent prefix + slash and prepend \"/\"\n      if (childNode.path === route.path) {\n        childNode.path = \"/\";\n      } else {\n        // compute slice index: for root parent \"/\" slice from 1, else route.path.length + 1\n        const baseIndex = route.path === \"/\" ? 1 : route.path.length + 1;\n        const rest = childNode.path.slice(baseIndex);\n        childNode.path = rest === \"\" ? \"/\" : \"/\" + rest;\n      }\n\n      node.children!.push(childNode);\n    }\n\n    if (node.children && node.children.length === 0) delete node.children;\n\n    return node;\n  }\n\n  const rootDef = fileRoutes.find((r) => r.path === \"/\");\n  if (!rootDef) throw new Error(\"Missing root /\");\n\n  return [buildNode(rootDef, fileRoutes)];\n}\n\nexport const routes = buildRouteTree();\n"],"names":["buildRouteTree","buildNode","route","all","$layout","$$layout","$component","$$component","Layout","require","default","Component","node","path","children","directChildren","filter","r","startsWith","rest","slice","length","includes","component","push","child","childNode","baseIndex","rootDef","fileRoutes","find","Error","routes"],"mappings":"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"}